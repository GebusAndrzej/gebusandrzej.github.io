---
layout: post
title: Flutter
categories: [content, flutter]
---

Some cool things in flutter ecosystem

### table of contents

- [Riverpod](#riverpod)
- [Hive](#hive)
- [Background Task](#background-fetch)
- [Local Notifications](#local-notifications)

---

# [Riverpod](https://pub.dev/packages/riverpod)

### Nice reactive state management for flutter application

Create provider:

{% highlight c %}
final someNotifier = ChangeNotifierProvider((ref) => _SomeState());

class _SomeState extends ChangeNotifier {
  late Box box; // <- you can even use hive here

  _SomeState() {
    box = Hive.box('someBox');
  }

  void someMethod() {
    // some code...

    notifyListeners(); // <- this wil ensure all observers will be notified of value change
  }
}

{% endhighlight %}

So.. how to get that data?

- ### Stateless widget

{% highlight c %}
class SomePage extends ConsumerWidget {
  SomePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final stateProvider = ref.watch(someNotifier); // <- and now you have access to the provider

    return ... // whatever;
  }
}
{% endhighlight %}

- ### Stateful widget

{% highlight c %}
class SomeStateFulPage extends ConsumerStatefulWidget {
  const SomeStateFulPage({super.key});

  @override
  _SomeStatefulPageState createState() => _SomeStatefulPageState();
}

class _SomeStatefulPageState extends ConsumerState<SomeStateFulPage> {
	_SomeStatefulPageState();

	@override
	Widget build(BuildContext context) {
		final stateProvider = ref.watch(someNotifier); // <- same thing, you have access to the provider

		return ... // whatever
	}
}
{% endhighlight %}

### Wrap application in provider scope

In main.dart 

{% highlight c %}
  runApp(const ProviderScope(
    child: MyApp(),
  ));
{% endhighlight %}

---

# [Hive](https://pub.dev/packages/hive)

On-device database that stores data i 'boxes'

nice & fast

### Create hive class

{% highlight c %}
import 'package:hive/hive.dart';

part 'SomeHiveClass.g.dart'; // <- this file will be generated by command

@HiveType(typeId: 1)
class SomeHiveClass {
  SomeHiveClass({
    required this.name,
    required this.url,
    this.maxZoom = 18,
    this.minZoom = 4,
  });

  @HiveField(0)
  late String name;

  @HiveField(1)
  late String url;

  @HiveField(2, defaultValue: 18)
  late double maxZoom;

  @HiveField(3, defaultValue: 4)
  late double minZoom;
}

{% endhighlight %}


> Note: You can use default values when you created new version of the class with new fields, but still want to use the same box. 
>
> Those new fields can be filled with default values when you want to access old stored items


### Generate hive part files
```
flutter packages pub run build_runner build
```

### Register Adapters in main.dart

{% highlight c %}
Future main() async {
  await Hive.initFlutter();

  Hive.registerAdapter(HivePlotAdapter()); // <- that generated .g.dart file

  await Hive.openBox('currentPlotBox'); // <- name of the box that stores data

  runApp(const ProviderScope( // <- this is from riverpod
    child: MyApp(),
  ));
}
{% endhighlight %}

> Note to myself: check [Try this pattern](https://medium.com/@avi261199/best-way-to-implement-hive-to-your-flutter-app-ee3e14f223df)

---

# [Background Fetch](https://pub.dev/packages/background_fetch)

//TODO

---

# [Local Notifications](https://pub.dev/packages/flutter_local_notifications)

// TODO